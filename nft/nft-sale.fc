;; NFT sale smart contract

int transfer_notify() asm "0x11 PUSHINT";
int tranfer_response() asm "0x80000012 PUSHINT";
int min_gas_amount() asm "1000000000 PUSHINT";
int equal_slices (slice a, slice b) asm "SDEQ";

(slice, slice, slice, int) load_data() inline {
  var ds = get_data().begin_parse();
  return 
    (ds~load_msg_addr(), ;; marketplace_address 
      ds~load_msg_addr(), ;; nft_address
      ds~load_msg_addr(),  ;; nft_owner_address
      ds~load_coins() ;; price
     );
}

() save_data(slice marketplace_address, slice nft_address, slice nft_owner_address, int price) impure inline {
  set_data(begin_cell()
    .store_slice(marketplace_address)
    .store_slice(nft_address)
    .store_slice(nft_owner_address)
    .store_grams(price)
    .end_cell());
}

() buy(int my_balance, slice nft_address, slice nft_owner_address, int price, int msg_value, slice sender_address, int query_id) impure {
  throw_unless(450, msg_value >= price + min_gas_amount());

  var msg1 = begin_cell()
           .store_uint(0x10, 6) ;; nobounce
           .store_slice(nft_owner_address)
           .store_grams(price + (my_balance - msg_value))
           .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

  send_raw_message(msg1.end_cell(), 1);

  var msg2 = begin_cell()
           .store_uint(0x18, 6) 
           .store_slice(nft_address)
           .store_grams(0)
           .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
           .store_uint(1, 32) ;; op = 1 transfer
           .store_uint(query_id, 64)
           .store_slice(sender_address) ;; new_owner_address
           .store_slice(sender_address) ;; response_address
           .store_int(0, 1) ;; empty InPayload
           .store_grams(0) ;; forward amount to new_owner_address
           .store_int(0, 1); ;; empty ForwardPayload


  send_raw_message(msg2.end_cell(), 128 + 32);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {  ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    var (marketplace_address, nft_address, nft_owner_address, price) = load_data();

    var is_initialized = nft_owner_address.slice_bits() > 2; ;; not initialized if null address

    if (~ is_initialized) {
      
      if (equal_slices(sender_address, marketplace_address)) {
         return (); ;; just accept coins on deploy
      }


      throw_unless(500, equal_slices(sender_address, nft_address));
      int op = in_msg_body~load_uint(32);
      throw_unless(501, op == transfer_notify());
      int query_id = in_msg_body~load_uint(64);
      slice prev_owner_address = in_msg_body~load_msg_addr();

      save_data(marketplace_address, nft_address, prev_owner_address, price);

      return ();

    }

    if (in_msg_body.slice_empty?()) {
        buy(my_balance, nft_address, nft_owner_address, price, msg_value, sender_address, 0);
        return ();
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    if (op == 1) { ;; just accept coins
        return ();
    }

    if (op == 2) { ;; buy
     
      buy(my_balance, nft_address, nft_owner_address, price, msg_value, sender_address, query_id);

      return ();

    }

    if (op == 3) { ;; cancel sale
         throw_unless(457, msg_value >= min_gas_amount());

         var msg = begin_cell()
           .store_uint(0x10, 6) ;; nobounce
           .store_slice(nft_address)
           .store_grams(0)
           .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
           .store_uint(1, 32) ;; op = 1 transfer
           .store_uint(query_id, 64) 
           .store_slice(nft_owner_address) ;; new_owner_address
           .store_slice(nft_owner_address) ;; response_address;
           .store_int(0, 1) ;; empty InPayload
           .store_grams(0) ;; forward amount to new_owner_address
           .store_int(0, 1); ;; empty ForwardPayload

        send_raw_message(msg.end_cell(), 128 + 32);

        return ();
    }

    throw(451);
    
}

() recv_external(slice in_msg) impure {
}

(slice, slice, slice, int) get_sale_data() method_id {
  var (marketplace_address, nft_address, nft_owner_address, price) = load_data();
  return (marketplace_address, nft_address, nft_owner_address, price);
}
